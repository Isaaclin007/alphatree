//
// Created by yanyu on 2017/8/28.
//

#ifndef ALPHATREE_ALPHAEXAMINER_H
#define ALPHATREE_ALPHAEXAMINER_H

#include "alpha/normal.h"
#include "alphaforest.h"
#include <float.h>
#include <random>
#include <iostream>
#include <math.h>
using namespace std;

struct AlphaExamRes{
    float avg{0};
    float std{0};
    float minAlpha{FLT_MAX};
    float maxAlpha{-FLT_MAX};
    int bestFutureNum{-1};
    int stockNum{0};
    float bestSharp{0};
};

class AlphaExaminer{
    public:
        static void initialize(AlphaForest* alphaForest);

        static void release();

        static AlphaExaminer* getAlphaexaminer();


        std::shared_future<AlphaExamRes> predict(int alphatreeId, int cacheMemoryId, int flagCacheId, int codesId, size_t futureNum, size_t sampleSize, size_t minSieveNum, size_t maxSieveNum,char* outCodes,
                                          float freeLogReturn = 0.002f, int punishNum = 6){
            return alphaForest_->getThreadPool()->enqueue([this, alphatreeId, cacheMemoryId, flagCacheId, codesId, futureNum, sampleSize, minSieveNum, maxSieveNum, freeLogReturn, punishNum, outCodes]{
                AlphaExamRes res = this->sharp(alphatreeId, cacheMemoryId, flagCacheId, codesId, futureNum, sampleSize, minSieveNum, maxSieveNum, freeLogReturn, punishNum).get();
                char* codes = this->alphaForest_->getCodesCache()->getCacheMemory(codesId);
                size_t stockSize = this->alphaForest_->getCodes(0, 0, this->alphaForest_->getHistoryDays(alphatreeId), 1, codes);
                //int nodeNum = this->alphaForest_->getNodeNum(alphatreeId);

                //分配缓存
                bool *flagCache = this->alphaForest_->getFlagCache()->getCacheMemory(flagCacheId);
                float *cacheMemory = this->alphaForest_->getAlphaTreeMemoryCache()->getCacheMemory(cacheMemoryId);

                const float* alphaRes = this->alphaForest_->calAlpha(alphatreeId, flagCache, cacheMemory, codes, 0, 1, stockSize).get();
                char* curOutCodes = outCodes;
                const char* curCodes = codes;
                res.stockNum = 0;
                for(size_t i = 0; i < stockSize; ++i){
                    int offset = strlen(curCodes) + 1;
                    if(alphaRes[i] >= res.minAlpha && alphaRes[i] < res.maxAlpha){
                        strcpy(curOutCodes,curCodes);
                        curOutCodes = curOutCodes + offset;
                        res.stockNum++;
                    }
                    curCodes = curCodes + offset;
                }
                curOutCodes[0] = 0;
                return res;
            }).share();
        }

        //找到夏普率最大的网眼
        //为什么不用ln(1+returns)的均值而用夏普率?因为我认为如果数据波动很大,很可能波动出一个假均值,这个均值很大但是不能重现.
        //我们取网眼中的数据本来量就不大,需要时刻提防小数定律.所以使用夏普率作为评估
        std::shared_future<AlphaExamRes> sharp(int alphatreeId, int cacheMemoryId, int flagCacheId, int codesId, size_t futureNum, size_t sampleSize, size_t minSieveNum, size_t maxSieveNum,
                                        float freeLogReturn = 0.002f, int punishNum = 6){
            char* codes = alphaForest_->getCodesCache()->getCacheMemory(codesId);
            //计算这段时间都有数据的stock
            size_t stockSize = alphaForest_->getCodes(0, futureNum, alphaForest_->getHistoryDays(alphatreeId), sampleSize, codes);
            int dateSize = AlphaDataBase::getElementSize(alphaForest_->getHistoryDays(alphatreeId), sampleSize, alphaForest_->getFutureDays(alphatreeId));
            int nodeNum = alphaForest_->getNodeNum(alphatreeId);

            //分配缓存
            bool *flagCache = alphaForest_->getFlagCache()->getCacheMemory(flagCacheId);
            float *cacheMemory = alphaForest_->getAlphaTreeMemoryCache()->getCacheMemory(cacheMemoryId);
            float *targetCache = AlphaTree::getNodeCacheMemory(nodeNum, dateSize, stockSize, cacheMemory);
            float *sieveSum = targetCache + stockSize * sampleSize;
            float *sieveSqrSum = sieveSum + maxSieveNum;
            int* sieveCount = (int*)(sieveSqrSum + maxSieveNum);

            std::shared_future<const float*> alphatreeRes = alphaForest_->calAlpha(alphatreeId, flagCache, cacheMemory, codes, futureNum, sampleSize,stockSize);
            AlphaDB* alphaDataBase = alphaForest_->getAlphaDataBase();

            return alphaForest_->getThreadPool()->enqueue([alphaDatabase, alphatreeRes, futureNum, sampleSize, stockSize, codes, minSieveNum, maxSieveNum, targetCache, sieveSum, sieveSqrSum, sieveCount, freeLogReturn, punishNum]{
                const float* alphaCache = alphatreeRes.get();
                float minAlpha = FLT_MAX;
                float maxAlpha = -FLT_MAX;
                getMinAndMax(alphaCache, sampleSize * stockSize, minAlpha, maxAlpha);

                AlphaExamRes res;
                //cout<<":"<<freeLogReturn<<" "<<minAlpha<<" "<<maxAlpha<<endl;

                //尝试所有可能的未来天数-----------------------------------------------------------------------------------------------
                for(int fIndex = 0; fIndex < futureNum; ++fIndex){
                    alphaDatabase->getTarget(fIndex, futureNum, sampleSize, stockSize, targetCache, codes);

                    //开始尝试渔网尺寸,找到最好的尺寸和位置-------------------
                    for(int sieveNum = minSieveNum; sieveNum <= maxSieveNum; sieveNum *= 2){
                        //初始化
                        memset(sieveSum, 0, sieveNum * sizeof(float));
                        memset(sieveSqrSum, 0, sieveNum * sizeof(float));
                        memset(sieveCount, 0, sieveNum * sizeof(int));

                        AlphaExaminer::sieve(alphaCache, targetCache, sampleSize, stockSize, sieveSum, sieveSqrSum, sieveCount, sieveNum, minAlpha, maxAlpha);
                        for(auto i = 0; i < sieveNum; ++i){
                            if(sieveCount[i] <= punishNum)
                                continue;
                            float avg = sieveSum[i]/sieveCount[i];
                            float std = sqrt(sieveSqrSum[i] / sieveCount[i] - avg * avg);
                            float scale = fmax((float)(sieveCount[i] - punishNum) / (float)sieveCount[i], 0);
                            float sharp = (scale * std == 0) ? 0 : (avg - freeLogReturn) * scale / std;

                            if(sharp > res.bestSharp){
                                res.bestSharp = sharp;
                                res.bestFutureNum = fIndex+1;
                                res.avg = avg;
                                res.std = std;
                                res.stockNum = sieveCount[i];
                                if(i == 0){
                                    res.minAlpha = -FLT_MAX;
                                    res.maxAlpha = (maxAlpha - minAlpha)/sieveNum + minAlpha;
                                } else if(i == sieveNum-1){
                                    res.minAlpha = maxAlpha - (maxAlpha - minAlpha)/sieveNum;
                                    res.maxAlpha = FLT_MAX;
                                } else{
                                    res.minAlpha = i * (maxAlpha - minAlpha)/sieveNum + minAlpha;
                                    res.maxAlpha = res.minAlpha + (maxAlpha - minAlpha)/sieveNum;
                                }
                            }
                        }
                    }

                }
                return res;
            }).share();
        }

        /*
        std::shared_future<float> filter(int alphatreeId,int cacheMemoryId, int flagCacheId, int codesId, size_t futureNum, size_t evalTime, size_t trainDateSize, size_t testDateSize, size_t minSieveNum, size_t maxSieveNum, int punishNum = 6){
            //先计算alphatree
            //cout<<"get codes"<<endl;
            size_t stockSize = alphaForest_->getCodes(0, futureNum, alphaForest_->getHistoryDays(alphatreeId), trainDateSize+testDateSize, alphaForest_->getCodesCache()->getCacheMemory(codesId));

            int dateSize = AlphaDataBase::getElementSize(alphaForest_->getHistoryDays(alphatreeId), testDateSize+trainDateSize, alphaForest_->getFutureDays(alphatreeId));
            int nodeNum = alphaForest_->getNodeNum(alphatreeId);

            //分配缓存
            bool *flagCache = alphaForest_->getFlagCache()->getCacheMemory(flagCacheId);
            float *cacheMemory = alphaForest_->getAlphaTreeMemoryCache()->getCacheMemory(cacheMemoryId);
            const char* codes = alphaForest_->getCodesCache()->getCacheMemory(codesId);
            float *targetCache = AlphaTree::getNodeCacheMemory(nodeNum, dateSize, stockSize, cacheMemory);
            float *sieveValue = targetCache + stockSize * (testDateSize + trainDateSize);
            int* sieveCount = (int*)(sieveValue + maxSieveNum);

            std::shared_future<const float*> alphatreeRes = alphaForest_->calAlpha(alphatreeId, flagCache, cacheMemory, codes, futureNum, testDateSize+trainDateSize,stockSize);
            AlphaDB* alphaDataBase = alphaForest_->getAlphaDataBase();
            //开始取样数据并验证,注意如果发现测试数据小于0就不再测试,直接返回
            return alphaForest_->getThreadPool()->enqueue([alphaDatabase, alphatreeRes, futureNum, evalTime, trainDateSize, testDateSize, stockSize, codes, minSieveNum, maxSieveNum, targetCache, sieveValue, sieveCount, punishNum]{
                //取样
                std::vector<int> shuffleIndex;
                const float* alphaCache = alphatreeRes.get();

                float minAlpha = FLT_MAX;
                float maxAlpha = -FLT_MAX;
                getMinAndMax(alphaCache, (testDateSize + trainDateSize) * stockSize, minAlpha, maxAlpha);

                int sampleSize = trainDateSize + testDateSize;

                float scoreSum = 0;
                for(int eid = 0; eid < evalTime; ++eid){
                    //得到洗牌后的数据
                    shuffleIndex.clear();
                    for(auto i = 0; i < sampleSize; ++i)
                        shuffleIndex.push_back(i);
                    unsigned seed = std::chrono::system_clock::now ().time_since_epoch ().count ();
                    std::shuffle (shuffleIndex.begin (), shuffleIndex.end (), std::default_random_engine (seed));

                    float bestScore = -FLT_MAX;
                    int bestFutureNum = 0;
                    float bestAlphaStart = FLT_MAX;
                    float bestAlphaEnd = -FLT_MAX;

                    //尝试所有可能的未来天数-----------------------------------------------------------------------------------------------
                    for(int fIndex = 0; fIndex < futureNum; ++fIndex){
                        alphaDatabase->getTarget(fIndex, futureNum, testDateSize + trainDateSize, stockSize, targetCache, codes);

                        //开始尝试渔网尺寸,找到最好的尺寸和位置-------------------
                        for(int sieveNum = minSieveNum; sieveNum <= maxSieveNum; sieveNum *= 2){
                            //初始化
                            memset(sieveValue, 0, sieveNum * sizeof(float));
                            memset(sieveCount, 0, sieveNum * sizeof(int));

                            AlphaExaminer::sieve(alphaCache, targetCache, 0, trainDateSize, stockSize, shuffleIndex, sieveValue, sieveCount, sieveNum, minAlpha, maxAlpha);
                            for(auto i = 0; i < sieveNum; ++i){
                                float score = (sieveValue[i]/(sieveCount[i] + punishNum));
                                if(score > bestScore){
                                    bestScore = score;
                                    bestFutureNum = fIndex+1;
                                    if(i == 0){
                                        bestAlphaStart = -FLT_MAX;
                                        bestAlphaEnd = (maxAlpha - minAlpha)/sieveNum + minAlpha;
                                        //bestAlphaEnd = avg - std * criticalValue;
                                    } else if(i == sieveNum-1){
                                        bestAlphaStart = maxAlpha - (maxAlpha - minAlpha)/sieveNum;
                                        bestAlphaEnd = FLT_MAX;
                                    } else{
                                        bestAlphaStart = i * (maxAlpha - minAlpha)/sieveNum + minAlpha;
                                        bestAlphaEnd = bestAlphaStart + (maxAlpha - minAlpha)/sieveNum;
                                    }
                                }
                            }
                        }

                    }

                    //验证-------------------------------------------------------------------------------------------------
                    //重新放入未来数据
                    alphaDatabase->getTarget(bestFutureNum-1, futureNum, testDateSize + trainDateSize, stockSize, targetCache, codes);
                    float score = AlphaExaminer::sieveEval(alphaCache, targetCache, trainDateSize, testDateSize, stockSize, shuffleIndex, bestAlphaStart, bestAlphaEnd, punishNum);
                    if(score < 0)
                        return score;
                    scoreSum += score;
                }
                return scoreSum / evalTime;
            });
        }*/

    protected:
        AlphaExaminer(AlphaForest* alphaForest):
                alphaForest_(alphaForest){
        }

        ~AlphaExaminer(){
            cout<<"release AlphaExaminer"<<endl;
        }

        inline static void getMinAndMax(const float* src, int size, float& minValue, float& maxValue){
            for(size_t i = 0; i < size; ++i){
                if(src[i] < minValue)
                    minValue = src[i];
                if(src[i] > maxValue)
                    maxValue = src[i];
            }
        }

        inline static void sieve(const float* alpha, const float* target, int sampleSize, int stockSize, float* sieveSum, float* sieveSqrSum,  int* sieveCount, int sieveNum, float minAlpha, float maxAlpha){
            float deltaAlpha = (maxAlpha - minAlpha) / sieveNum;
            for(auto i = 0; i < sampleSize; ++i){
                const float* curAlpha = alpha + i * stockSize;
                const float* curTarget = target + i * stockSize;
                for(size_t j = 0; j < stockSize; ++j){
                    int sieveIndex = (int)((curAlpha[j] - minAlpha) / deltaAlpha);
                    if(sieveIndex < 0)
                        sieveIndex = 0;
                    else if(sieveIndex >= sieveNum)
                        sieveIndex = sieveNum - 1;
                    sieveSum[sieveIndex] += curTarget[j];
                    sieveSqrSum[sieveIndex] += curTarget[j] * curTarget[j];
                    ++sieveCount[sieveIndex];
                }
            }
        }

        /*
        inline static void sieve(const float* alpha, const float* target, int startSampleIndex, int sampleSize, int stockSize, std::vector<int>& shuffleIndex, float* sieveValue, int* sieveCount, int sieveNum, float minAlpha, float maxAlpha){
            float deltaAlpha = (maxAlpha - minAlpha) / sieveNum;
            for(auto i = 0; i < sampleSize; ++i){
            const float* curAlpha = alpha + shuffleIndex[startSampleIndex+i] * stockSize;
            const float* curTarget = target + shuffleIndex[startSampleIndex+i] * stockSize;
            for(size_t j = 0; j < stockSize; ++j){
                    int sieveIndex = (int)((curAlpha[j] - minAlpha) / deltaAlpha);
                    if(sieveIndex < 0)
                        sieveIndex = 0;
                    else if(sieveIndex >= sieveNum)
                        sieveIndex = sieveNum - 1;
                    sieveValue[sieveIndex] += curTarget[j];
                    ++sieveCount[sieveIndex];
                }
            }
        }


        inline static float sieveEval(const float* alpha, const float* target, int startSampleIndex, int sampleSize, int stockSize, std::vector<int>& shuffleIndex, float alphaStart, float alphaEnd, int punishNum){
            float scoreSum = 0;
            int scoreCount = 0;
            for(auto i = 0; i < sampleSize; ++i){
                const float* curAlpha = alpha + shuffleIndex[startSampleIndex+i] * stockSize;
                const float* curTarget = target + shuffleIndex[startSampleIndex+i] * stockSize;
                for(size_t j = 0; j < stockSize; ++j){
                    if(curAlpha[j] >= alphaStart && curAlpha[j] < alphaEnd){
                        scoreSum += curTarget[j];
                        ++scoreCount;
                    }

                }
            }

            return scoreSum / (scoreCount + punishNum);
        }
         */

        AlphaForest* alphaForest_;

        static AlphaExaminer* alphaExaminer_;
};

void AlphaExaminer::initialize(AlphaForest* alphaForest){
    release();
    alphaExaminer_ = new AlphaExaminer(alphaForest);
}

void AlphaExaminer::release(){
    if(alphaExaminer_)
        delete alphaExaminer_;
    alphaExaminer_ = nullptr;
}

AlphaExaminer* AlphaExaminer::getAlphaexaminer(){ return alphaExaminer_;}

AlphaExaminer* AlphaExaminer::alphaExaminer_ = nullptr;

#endif //ALPHATREE_ALPHAEXAMINER_H
